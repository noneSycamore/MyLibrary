
# python 拼图游戏的实现
## 前言~
一个拼图游戏，做完之后感觉，功能方面和我的预期还是基本一样的 (￣_,￣ )
就是，这个美化做的不是很好，就先这样了ㄟ( ▔, ▔ )ㄏ
## 系统概述
目标是设计出一个支持鼠标拖动拼图的游戏软件myPuzzle，
可以自由选择图片，能够自定义分割的数量（就比如3*3的九宫格之类的），打乱顺序之后放置在不同的图片框中，用户使用鼠标拖动图片框中的图片进行拼图，
还加了一个挑战模式

## 系统设计
具体功能如下：
	1.自由选择打算进行拼图游戏的图片。
	2.自定义分割图片的数量。
	3.打乱分割后的图片并重新排列在图片框内。
	4.实现用鼠标拖动图片来交换图片顺序，达到拼图的目的。
	5.能查看原图。
	6.可以选择重新开始。
	7.添加挑战模式，在倒计时结束前完成拼图。
	8.能实时显示拼图所花的步骤
**一些小改动**：
	1.拖动的图片不会超过原图边界显示，超出则步数+1
	2.选中的图片将随鼠标移动，且处于其他图片的上方显示
	3.修改了 重新开始 功能的一个小bug.
## 运行界面
部分简单的画面就略去啦，消息框啥的这里也没加上（太多了）
1.默认分割完的图片
![](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt1.png)
2.右侧的选项
![enter image description here](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt2.png)
3.打开文件的画面
![enter image description here](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt3.png)
4.自由选择分割的难度，（上限为8）
![enter image description here](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt4.png)
5.挑战模式
![enter image description here](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt8.png)
![enter image description here](https://cdn.jsdelivr.net/gh/noneSycamore/whitzard_cdn/wp-content/uploads/2021/09/pt11.png)

## 代码实现
```python
# -*- coding: UTF-8 -*-
from tkinter import *
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import random

root=Tk("myPuzzle")
root.title("myPuzzle")
root.geometry('1500x800')
cv=Canvas(root,bg="white",width=800,height=800)
Label1=Label(root,text="0",fg="red",font = ('黑体',25))
time_left = 60
depth=3
steps=0
board=[[0,1,2],[3,4,5],[6,7,8]]
suffixs = ['png','jpg','jpeg']

index_list=[]
Pics=[]
Pic_path = "R.jpg"   #默认路径
im = Image.open(Pic_path)  # 读取图片
width, height= im.size

wid = width   #保存原图数据并修改大小
hei = height
im = im.resize((int(wid*0.18*depth), int(hei*0.18*depth)), Image.ANTIALIAS)
width, height = im.size
w = int(width/depth)
h = int(height/depth)
clickID=-1   #图片随鼠标移动参数

class Square:
    def __init__(self,ID):
        self.ID=ID
    def draw(self,canvas,board_pos):
        img=tkImage_list[self.ID]
        canvas.create_image(board_pos,image=img)

def load():
    global pic_radio, depth_var
    Label(root,text="请选择游戏难度:",font = ('黑体',15),).place(x=800,y=40+20)#int(w*depth/2.6)
    open_file = Button(root,text='打开图片(默认R.jpg)', height=2,\
        font = ('黑体',15), command = open_pic).place(x=int(w*0.87)+800,y=0)
    depth_var = StringVar()
    Label(root,text="自定义切割边数:",font = ('黑体',15)).place(x=800,y=70+25)
    Label(root,text="(0 < 边数 < 9)",font = ('黑体',14),).place(x=800,y=95+25)
    Entry(root, textvariable=depth_var).place(x=int(w*0.9)+800,y=75+25,height=40,width=190)
    Button(root,text='确定', font = ('黑体',15), width = 16, command = newdepth)\
        .place(x=int(w*2.01)+800,y=70+25,height=50,width=180)
    pic_radio = IntVar()
    pic_radio.set(3)
    radio1 = Radiobutton(root, text='四宫格',font = ('黑体',15), \
        value = 2,variable = pic_radio,command = catch).place(x=int(w/1.05)+800,y=40+20)
    radio2 = Radiobutton(root,text ='九宫格',font = ('黑体',15), \
        value=3,variable = pic_radio,command = catch).place(x=int(w*1.60)+800,y=40+20)
    radio3 = Radiobutton(root, text='十六宫格',font = ('黑体',15), \
        value=4,variable=pic_radio,command = catch).place(x=int(w*2.27)+800,y=40+20)
    Button(root,text="重新开始",command=game_loop,font = ('黑体',15))\
        .place(x=800,y=170,height=50,width=180)
    Label(root,text="Steps:",font = ('黑体',22)).place(x=int(w*0.02)+800,y=13)
    Button(root,text="查看原图",command=show_image,font = ('黑体',15))\
        .place(x=800,y=320,height=50,width=180)
    Button(root,text="挑战模式",command=challenge,font = ('黑体',15))\
        .place(x=800,y=470,height=50,width=180)

def open_pic():
    global Pic_path
    file_path = filedialog.askopenfilename()
    if file_path:
        suffix = file_path.split('.')[1]
        if suffix in suffixs:
            Pic_path = file_path
            messagebox.showwarning('完成','已打开！请选择游戏难度')
        else:
            messagebox.showwarning('警告','请选择图片文件')
    else:
        messagebox.showwarning('友情提示','文件路径错误，或没有打开文件')
    game_loop()

def newdepth():
    global depth, w, h, tkImage_list, index_list, im, width, height, board, steps
    board = []
    steps = 0
    Label1["text"]=str(steps)
    tkImage_list = []
    index_list = []
    depth = int(depth_var.get())
    if(depth > 8):
        messagebox.showwarning('警告','难度过大，切割数上限为8，请重新设置~')
        return
    if(depth < 1):
        messagebox.showwarning('警告','切割数不能小于1~')
    im = Image.open(Pic_path)
    im = im.resize((int(wid*0.1*depth), int(hei*0.1*depth)), Image.ANTIALIAS)
    width, height = im.size
    w = int(width/depth)
    h = int(height/depth)
    for i in range(depth):
        board.append([])
        for j in range(depth):
            board[i].append(i * depth + j)
    cut_image(im)
    shuffle_list() 
    for i in range(depth):
        for j in range(depth):
            idx=i*depth+j
            ID=index_list[idx]
            board[i][j]=Square(ID)
    show_image_list()

def catch():
    global depth, w, h, tkImage_list, index_list, im, width, height, board, steps
    board = []
    steps = 0
    Label1["text"]=str(steps)
    tkImage_list = []
    index_list = []
    depth = int(pic_radio.get())
    im = Image.open(Pic_path)
    im = im.resize((int(wid*0.1*depth), int(hei*0.1*depth)), Image.ANTIALIAS)
    width, height = im.size
    w = int(width/depth)
    h = int(height/depth)
    for i in range(depth):
        board.append([])
        for j in range(depth):
            board[i].append(i * depth + j)
    cut_image(im)
    shuffle_list() 
    for i in range(depth):
        for j in range(depth):
            idx=i*depth+j
            ID=index_list[idx]
            board[i][j]=Square(ID)
    show_image_list()

def cut_image(Pic):
    global tkImage_list
    for i in range(depth):
        for j in range(depth):
            box = (w * j, h * i, w * (j + 1), h * (i + 1))  # 需要切割的矩形区域
            image = Pic.crop(box)
            tkImage_list.append(ImageTk.PhotoImage(image))
            index_list.append(i * depth + j)  # 分割图片并存进tkImage_list中

def shuffle_list():
    global index_list
    reverseCount = 0
    random.shuffle(index_list)
    for i in range(len(index_list)):
        for j in range(i):
            if index_list[i] < index_list[j]:
                reverseCount += 1  # 计算逆序数
    if reverseCount % 2 != 0:
        shuffle_list()

def show_image_list():
    # 通过index_list展示image_list中的图片
    num = 0
    for index in index_list:
        show_single_img(index, num)
        num += 1

def show_single_img(index, num):
    #根据索引在位置num处画出单张图片
    i = num//depth
    j = num % depth
    canvas=tkImage_list[index]
    board[i][j].draw(cv,(w*(j+0.5),h*(i+0.5)))

def show_image():
    root2=Toplevel(root)
    root2.title("原图")
    Img = Image.open(Pic_path)
    Img = Img.resize((int(wid*0.5), int(hei*0.5)), Image.ANTIALIAS)
    img = ImageTk.PhotoImage(Img)
    label_Img = Label(root2, image=img).pack()
    root2.mainloop()

def challenge():
    global Label2,time_radio,reset
    Label(root,text="请在倒计时结束前完成拼图！",font = ('黑体',16)).place(x=int(w*0.05)+800,y=525)
    Label(root,text="请选择时间：",font = ('黑体',17)).place(x=int(w*0.05)+800,y=550)
    time_radio = IntVar()
    time_radio.set(3)
    radio1 = Radiobutton(root, text='1 分钟',font = ('黑体',15), \
        value=60,variable = time_radio,command = gettime).place(x=int(w*1.45)+800,y=550)
    radio2 = Radiobutton(root,text ='2 分钟',font = ('黑体',15), \
        value=120,variable = time_radio,command = gettime).place(x=int(w*2.40)+800,y=550)
    radio3 = Radiobutton(root, text='3 分钟',font = ('黑体',15), \
        value=180,variable=time_radio,command = gettime).place(x=int(w*3.3)+800,y=550)
    Label2=Label(root,text=str(time_left),fg="red",font = ('黑体',25))
    Label2.place(x=int(w*1.2)+800,y=608)
    Label(root,text="倒计时:",font = ('黑体',22)).place(x=int(w*0.05)+800,y=610)
    reset=0
    Button(root,text="重置！",command=getreset,font = ('黑体',15))\
        .place(x=int(w*1.95)+800,y=598,height=50,width=160)

def gettime():
    global reset
    if(reset==3):
        global l1,l2,l3
        l1.place_forget()
        l2.place_forget()
        l3.place_forget()
        reset=0
    n=int(time_radio.get())
    cut_down(n)

def getreset():
    global reset
    reset=1

def cut_down(n):
    global Label2,time_radio,reset,l1,l2,l3
    if n !=0:
        Label2['text'] = str(n)
    else:
        messagebox.showinfo(title="警告",message="时间到！")
        root.after_cancel(id)
    n=n-1
    id=root.after(1000,cut_down,n)
    if(reset==1):
        root.after_cancel(id)
        Label2['text'] = time_radio.get()
        reset=0
    if(reset==2):
        root.after_cancel(id)
        l1=Label(root,text="挑战成功！你的用时为",font = ('黑体',18))
        l1.place(x=int(w*0.05)+800,y=650)
        l2=Label(root,text=str(int(time_radio.get())-n-1),fg="red",font = ('黑体',18))
        l2.place(x=int(w*2.5)+800,y=650)
        l3=Label(root,text='s',font = ('黑体',18))
        l3.place(x=int(w*2.9)+800,y=650)
        reset=3

def StartMove(event):
    global first_r,first_c,first_square
    first_r=int(event.y//h)
    first_c=int(event.x//w)
    if first_r<depth and first_c<depth:
        first_square=board[first_r][first_c]
    board[first_r][first_c].draw(cv,(w*(first_c+0.5),h*(first_r+0.5)))
    # 图片随鼠标移动
    global first_x,first_y,clickID
    allID=cv.find_closest(event.x,event.y)
    if len(allID) > 0:
        clickID=allID[0]
        first_x,first_y = event.x,event.y 

def StopMove(event):
    global steps,first_r,first_c,cur_r,cur_c,first_square,reset
    cur_r=int(event.y//h)
    cur_c=int(event.x//w)
    if cur_r<depth and cur_c<depth:
        current_square=board[cur_r][cur_c]
        board[cur_r][cur_c]=first_square
        board[first_r][first_c]=current_square
        steps+=1
        Label1["text"]=str(steps)
        cv.delete("all")
        show_image_list()
    else:
        steps+=1
        Label1["text"]=str(steps)
        cv.delete("all")
        show_image_list()
    if win():
        reset=2  #重置时间设定为2，代表成功
        messagebox.showinfo(title="恭喜",message="拼图成功！")
    #图片随鼠标移动
    global first_x,first_y,clickID
    cv.move(clickID,event.x-first_x,event.y-first_y)
    clickID=-1

def OnMotion(event): #图片随鼠标移动
    global first_x,first_y,clickID
    if clickID!=-1:
        cv.move(clickID,event.x-first_x,event.y-first_y)
        first_x,first_y = event.x,event.y

def win():
    for i in range(depth):
        for j in range(depth):
            if board[i][j] is not None and board[i][j].ID!=i*depth+j:
                return False
    return True

def game_loop():
    global reset
    reset=1
    cv.update()
    try:
        depth = int(depth_var.get())
        newdepth()
        show_image_list()
    except:
        depth = int(pic_radio.get())
        catch()
        show_image_list()

def main():
    load()
    Label1.place(x=int(w*0.55)+800,y=13)
    cv.bind("<ButtonPress-1>",StartMove)  #绑定鼠标左键按下事件
    cv.bind("<ButtonRelease-1>",StopMove) #绑定鼠标左键松开事件
    cv.bind("<B1-Motion>", OnMotion) #绑定鼠标移动事件
    cv.place(x=0,y=0)
    game_loop()
    root.mainloop()

if __name__ == '__main__':
    main()

```
